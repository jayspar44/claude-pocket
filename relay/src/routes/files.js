const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const logger = require('../logger');
const ptyRegistry = require('../pty-registry');

const router = express.Router();

// Get working directory from PTY registry (default instance)
function getWorkingDir() {
  const defaultInstance = ptyRegistry.getDefault();
  return defaultInstance?.currentWorkingDir;
}

// Ensure path is within working directory (security)
function isPathSafe(requestedPath) {
  const workingDir = getWorkingDir();
  if (!workingDir) return false;
  const resolved = path.resolve(workingDir, requestedPath);
  return resolved.startsWith(workingDir);
}

// List files in a directory
router.get('/', async (req, res) => {
  try {
    const workingDir = getWorkingDir();
    if (!workingDir) {
      return res.status(503).json({ error: 'PTY not running - no working directory set' });
    }

    const requestedPath = req.query.path || '';

    if (!isPathSafe(requestedPath)) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const fullPath = path.resolve(workingDir, requestedPath);

    const stats = await fs.stat(fullPath);
    if (!stats.isDirectory()) {
      return res.status(400).json({ error: 'Path is not a directory' });
    }

    const entries = await fs.readdir(fullPath, { withFileTypes: true });

    const items = await Promise.all(
      entries
        .filter(entry => !entry.name.startsWith('.')) // Hide dotfiles by default
        .map(async (entry) => {
          const entryPath = path.join(fullPath, entry.name);
          try {
            const entryStat = await fs.stat(entryPath);
            return {
              name: entry.name,
              type: entry.isDirectory() ? 'directory' : 'file',
              size: entry.isFile() ? entryStat.size : null,
              modified: entryStat.mtime,
            };
          } catch {
            return {
              name: entry.name,
              type: entry.isDirectory() ? 'directory' : 'file',
              size: null,
              modified: null,
            };
          }
        })
    );

    // Sort: directories first, then files, alphabetically
    items.sort((a, b) => {
      if (a.type === 'directory' && b.type !== 'directory') return -1;
      if (a.type !== 'directory' && b.type === 'directory') return 1;
      return a.name.localeCompare(b.name);
    });

    res.json({
      path: requestedPath,
      fullPath,
      items,
    });
  } catch (error) {
    if (error.code === 'ENOENT') {
      return res.status(404).json({ error: 'Path not found' });
    }
    logger.error({ error: error.message }, 'Failed to list files');
    res.status(500).json({ error: 'Failed to list files' });
  }
});

// Upload file (any type)
router.post('/upload', express.raw({ type: '*/*', limit: '10mb' }), async (req, res) => {
  logger.info({
    contentType: req.headers['content-type'],
    contentLength: req.headers['content-length'],
    filename: req.query.filename,
    bodySize: req.body?.length,
  }, 'Upload request received');

  try {
    const workingDir = getWorkingDir();
    if (!workingDir) {
      return res.status(503).json({ error: 'PTY not running - no working directory set' });
    }

    const filename = req.query.filename || `upload-${Date.now()}.png`;
    const destPath = req.query.path || '';

    if (!isPathSafe(destPath)) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Upload to .claude-pocket/uploads/ subdirectory (git-ignored)
    const uploadDir = path.join(workingDir, '.claude-pocket', 'uploads');
    const fullPath = path.resolve(uploadDir, destPath, filename);

    // Ensure upload directory exists
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Create .gitignore in .claude-pocket/ if it doesn't exist
    const gitignorePath = path.join(workingDir, '.claude-pocket', '.gitignore');
    try {
      await fs.access(gitignorePath);
    } catch {
      await fs.writeFile(gitignorePath, '# Auto-generated by Claude Pocket\n*\n!.gitignore\n');
    }

    // Write file
    await fs.writeFile(fullPath, req.body);

    // Return relative path from working directory
    const relativePath = path.relative(workingDir, fullPath);

    res.json({
      success: true,
      path: fullPath,
      relativePath,
    });
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to upload file');
    res.status(500).json({ error: 'Failed to upload file' });
  }
});

// Get working directory info
router.get('/info', (req, res) => {
  const workingDir = getWorkingDir();
  res.json({
    workingDir: workingDir || null,
    separator: path.sep,
  });
});

// Upload file as base64 (more reliable over unstable connections)
router.post('/upload-base64', express.json({ limit: '15mb' }), async (req, res) => {
  try {
    const workingDir = getWorkingDir();
    if (!workingDir) {
      return res.status(503).json({ error: 'PTY not running - no working directory set' });
    }

    const { data, filename, contentType } = req.body;
    if (!data || !filename) {
      return res.status(400).json({ error: 'Missing data or filename' });
    }

    logger.info({ filename, contentType, dataLength: data.length }, 'Base64 upload received');

    // Decode base64
    const buffer = Buffer.from(data, 'base64');

    // Upload to .claude-pocket/uploads/ subdirectory
    const uploadDir = path.join(workingDir, '.claude-pocket', 'uploads');
    const fullPath = path.resolve(uploadDir, filename);

    // Ensure upload directory exists
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Create .gitignore if it doesn't exist
    const gitignorePath = path.join(workingDir, '.claude-pocket', '.gitignore');
    try {
      await fs.access(gitignorePath);
    } catch {
      await fs.writeFile(gitignorePath, '# Auto-generated by Claude Pocket\n*\n!.gitignore\n');
    }

    // Write file
    await fs.writeFile(fullPath, buffer);

    const relativePath = path.relative(workingDir, fullPath);
    logger.info({ filename, size: buffer.length, relativePath }, 'Base64 upload complete');

    res.json({
      success: true,
      path: fullPath,
      relativePath,
    });
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to upload base64 file');
    res.status(500).json({ error: 'Failed to upload file' });
  }
});

// Clean up .claude-pocket directory (uploads, temp files, etc.)
router.delete('/cleanup', async (req, res) => {
  try {
    const workingDir = getWorkingDir();
    if (!workingDir) {
      return res.status(503).json({ error: 'PTY not running - no working directory set' });
    }

    const claudePocketDir = path.join(workingDir, '.claude-pocket');
    let deletedFiles = 0;
    let deletedSize = 0;

    // Check if directory exists
    try {
      await fs.access(claudePocketDir);
    } catch {
      return res.json({ success: true, deletedFiles: 0, deletedSize: 0, message: 'No .claude-pocket directory found' });
    }

    // Recursively get all files to delete (except .gitignore and output-buffer.json)
    const filesToKeep = ['.gitignore', 'output-buffer.json'];

    async function deleteRecursive(dir) {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          await deleteRecursive(fullPath);
          // Try to remove empty directory
          try {
            const remaining = await fs.readdir(fullPath);
            if (remaining.length === 0) {
              await fs.rmdir(fullPath);
            }
          } catch {
            // Ignore errors removing directories
          }
        } else if (!filesToKeep.includes(entry.name)) {
          try {
            const stats = await fs.stat(fullPath);
            deletedSize += stats.size;
            await fs.unlink(fullPath);
            deletedFiles++;
          } catch (err) {
            logger.warn({ error: err.message, path: fullPath }, 'Failed to delete file');
          }
        }
      }
    }

    await deleteRecursive(claudePocketDir);

    logger.info({ deletedFiles, deletedSize, workingDir }, 'Cleaned up .claude-pocket directory');
    res.json({
      success: true,
      deletedFiles,
      deletedSize,
      message: `Deleted ${deletedFiles} files (${(deletedSize / 1024).toFixed(1)} KB)`,
    });
  } catch (error) {
    logger.error({ error: error.message }, 'Failed to cleanup files');
    res.status(500).json({ error: 'Failed to cleanup files' });
  }
});

module.exports = router;
